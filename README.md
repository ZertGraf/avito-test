# PR Reviewer Assignment Service

микросервис для автоматического назначения ревьюеров на pull request'ы с управлением командами и пользователями.

## быстрый старт

```bash
# запуск через docker-compose (требуется только docker)
docker-compose up

# сервис будет доступен на http://localhost:8080
# health check: http://localhost:8080/health
```

миграции применяются автоматически при старте сервиса.

## технический стек

- **язык**: Go 1.24
- **база данных**: PostgreSQL 15
- **драйвер БД**: github.com/jackc/pgx/v5 (чистый SQL, без ORM)
- **миграции**: jackc/tern
- **роутер**: go-chi/chi/v5
- **логирование**: log/slog

## архитектура

проект следует принципам чистой архитектуры с разделением на слои:

```
internal/
├── api/              # http handlers и middleware
│   ├── handler/     # обработчики запросов
│   └── middleware/  # middleware компоненты
├── service/         # бизнес-логика
├── repository/      # работа с БД
├── domain/          # доменные модели и ошибки
└── pkg/             # общие утилиты (logger, config, postgres)
```

### ключевые архитектурные решения

1. **зависимости через интерфейсы**: repository объявлены как интерфейсы в `repository/interfaces.go`, что позволяет легко мокать для тестов
2. **транзакции на уровне repository**: сложные операции (создание команды с участниками) выполняются атомарно
3. **context propagation**: контекст передаётся через все слои для cancellation и timeouts
4. **graceful shutdown**: корректное завершение при получении SIGTERM/SIGINT с таймаутом 30с

## команды разработки

### docker (рекомендуется)

```bash
make help              # показать все команды
make dev               # быстрый старт с чистой БД
make docker-up         # запустить сервисы
make docker-down       # остановить сервисы
make docker-logs       # показать логи
make docker-logs-app   # логи только приложения
```

### локальная разработка

требования: Go 1.24+, PostgreSQL 15+

```bash
# установить зависимости
make deps

# запустить базу через docker
docker-compose up postgres -d

# запустить приложение
make run
```

### сборка

```bash
make build             # собрать бинарник
make docker-build      # собрать docker образ
make all               # полная проверка и сборка
```

## структура API

см. [openapi.yml](openapi.yml) для полной спецификации.

### основные endpoints

**teams**
- `POST /team/add` - создать команду с участниками
- `GET /team/get?team_name=X` - получить команду

**users**
- `POST /users/setIsActive` - изменить статус активности
- `GET /users/getReview?user_id=X` - получить PR'ы пользователя

**pull requests**
- `POST /pullRequest/create` - создать PR (авто-назначение ревьюеров)
- `POST /pullRequest/merge` - мержить PR (идемпотентно)
- `POST /pullRequest/reassign` - переназначить ревьювера

## бизнес-логика

### назначение ревьюеров

- при создании PR автоматически выбираются до 2 активных ревьюеров из команды автора
- автор исключается из кандидатов
- если доступных кандидатов < 2, назначается доступное количество (0/1)
- выбор случайный

### переназначение

- КРИТИЧЕСКИ: кандидаты ищутся из команды **заменяемого** ревьювера, не автора
- исключаются: автор PR + все текущие ревьюеры
- если нет кандидатов → ошибка `NO_CANDIDATE`
- после merge переназначение запрещено

### идемпотентность merge

повторный вызов `/pullRequest/merge` на уже merged PR возвращает текущее состояние без ошибки. это важно для надёжности в распределённых системах.

## обработка ошибок

доменные ошибки определены в `domain/errors.go` и мапятся на правильные HTTP коды:

- `TEAM_EXISTS` (400) - команда существует
- `PR_EXISTS` (409) - PR существует
- `PR_MERGED` (409) - PR уже merged
- `NOT_ASSIGNED` (409) - пользователь не назначен ревьювером
- `NO_CANDIDATE` (409) - нет доступных кандидатов
- `NOT_FOUND` (404) - ресурс не найден

## производительность

### целевые метрики (из задания)

- RPS: 5
- SLI времени ответа: 300ms
- SLI успешности: 99.9%

### оптимизации

1. **connection pooling**: 25 connections max, правильно настроенные таймауты
2. **индексы**: на user.team_name, user.is_active, pr_reviewers.reviewer_id
3. **prepared statements**: pgx автоматически кэширует
4. **транзакции**: минимальный scope, только где необходима атомарность

## конфигурация

конфигурация через environment variables. см. `.env` для примера.

## миграции

миграции в `migrations/*.sql` применяются автоматически через tern при старте.

текущая схема:
- `teams` - команды
- `users` - пользователи (FK на teams)
- `pull_requests` - PR'ы (FK на users через author_id)
- `pr_reviewers` - связь many-to-many PR ↔ reviewers

## известные ограничения и решения

### вопрос: как обрабатывать race conditions при назначении?

**решение**: используем транзакции на уровне repository. для создания команды с участниками вся операция выполняется атомарно. для переназначения используется `UPDATE ... WHERE status = 'OPEN'` с проверкой affected rows.

### вопрос: что если пользователь деактивируется после назначения?

**решение**: деактивированные пользователи остаются ревьюверами на уже созданных PR. это соответствует реальному workflow - если человек взял на себя review, он должен его завершить даже если уходит из команды.

### вопрос: как обеспечить fairness при random выборе?

**решение**: используем `math/rand` с seed от `time.Now().UnixNano()` + sync.Mutex для thread-safety.

## деплой соображения

### health checks

`GET /health` возвращает статус сервиса. используется в kubernetes readiness/liveness probes.

## FAQ

**Q: почему не использовали ORM?**
A: требование задания - показать знание SQL. чистый SQL через pgx даёт полный контроль над запросами и лучшую производительность.

**Q: как добавить новый endpoint?**
A: 1) добавить handler в `internal/api/handler`, 2) зарегистрировать в Routes(), 3) добавить бизнес-логику в service layer, 4) если нужно - новые методы в repository.